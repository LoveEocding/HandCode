# 什么是javascript执行上下文
我的理解是一段javascript执行所需要的具体内容和环境，例如全局执行上下文，包括全局环境变量，可执行代码等。

# 介绍一下javascript作用域链条
javascript作用域依据词法作用域也就是代码编写的位置。比如寻找一个变量在当前函数作用域或者块级作用域找到，就向上一级作用域寻找，这一个现象可以理解为作用域链条

# javascript闭包和应用场景
1：javascipt闭包是指，比如一个函数中，在声明一个函数，这个函数使用上一层函数的变量，本来上一层函数执行完成以后，函数栈弹出。变量应该被垃圾回收机制清除，但是里面的函数还在使用这些变量，引擎默认会给这个函数创建一个闭包的引用，指向内存堆中这个数据对象，这些变量就成为了这个函数专用的数据包，可以称为闭包。
2：应用场景：函数柯里化，可以把这些变量用于下次的计算，隐藏变量作为独立函数作用域里面，不暴露出去。不污染全局变量

# 介绍一下javascript this
## 从字面意思来看就是指当前执行的上下文，然后分环境比如游览器中，全局默认this 就是window,在对象中this就是指向这个对象。

# 如果改变this
可以分为显示的改变和隐式的改变，比如使用构造函数创建一个对象，引擎默认的步骤就是创建一个空对象，然后复制属性，然后把当前的this指向构造函数对象所执行的this。显示的使用bind call apply 动态绑定this

# call apply有什么不同
第二个参数的不同call 后面是枚举的参数 ，apply 后面是一个集合的arguments参数

# 如何实现一个call apply
```
Funciton.prototype.call2=function(thisArg,arguments){
     var _this=this; //代表上一个对象
     if(typeof _this !=='function'){
         throw new Error('not a function');
     }
     if(!thisArg){
         thisArg=window;
     }

     thisArg['changethis']=_this;
     return thisArg['changethis'](...arguments);
}

//bind
Function.prototype.bind=function(thisArg){
    var target=this;
    if(typeof target !==='function'){
        throw new Error(taraget+'must be function');
    }
    var args=[].slice.call(arguments,1);
    var bound=function(){
        var boundArg=[].slice.call(arguments);
        var findArg=args.concact(boundArg);
        if(this instanceof bound){  //如果是new 操作
           //1创建一个空对象指向原型
           if(target.prototype){
               bound.prototype=Object.create(target.prototype);
           }
           var result=self.apply(this,findArg);
           //如果函数没有返回对象object
           var isObject=typeof result==='object'&&result!==null;
           var isFunction=typeof result==='function';
           if(isObject||isFunction){
               return result;
           }
           return this;
        }
        return target.apply(thisArg,findArg);
    }
    return bound;
}
```
# 介绍一下javascript原型，原型链
原型就是一个对象中的属性，在执行查找属性操作的时候，如果在当前查找不到，如果有原型属性有引用的值，我向这个原型执行委托行为，向这个原型继续查找。这种关联 关系可以视为原型链

# 如何使用原型实现继承
我的理解是这种继承应该是关联关系，而不是如java语言继承是复制一个副本出来。如果要继承一个父级的东西可以用Object.create注入一个对象。新对象中的原型引用会执行这个父级对象。但是只是引用是互联的关系，而不是一个副本。如果直接改变子级别的原型内容，对应的父级内容也会改变。

# promise 是什么
promise是es6为了解决异步调用一种解决方案

# 手动写一个promise
```
function Promise(){
    
}
```